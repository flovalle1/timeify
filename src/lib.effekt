module src/lib
import io/console

def helloWorld(): String = "Hello, world!"

extern def calcTimeDiffInSecs(startIsoString: String, endIsoString: String): Int =
  jsNode "Math.floor((new Date(${endIsoString}) - new Date(${startIsoString}))/1000)"

extern def getCurrentTime(): String =
  jsNode "new Date().toISOString();"

extern def convertSecsToHMS(secs: Int): String =
  jsNode "new Date(${secs} * 1000).toISOString().substr(11, 8)"

extern def sendTimerStartedRequest(): Unit =
  jsNode "fetch('http://localhost:3000/tracking-started', { method: 'POST' })"


interface UserInput {
  def startTimer(): Unit
  def stopTimer(): Unit
  def quitMainLoop(): Unit
  def switchProject(projectName: String): Unit
}

type TimerState {
  Stopped()
  Running()
}

def handleInput() {handler: UserInput}: Unit = {
  with console;
  val input = do readLine()

  if (input == "s") {
    handler.startTimer()
  }
  else if (input == "p") {
    handler.stopTimer()
  }
  else if (input == "q") {
    handler.quitMainLoop()
  }
  else if (input == "n") {
    println("Enter project name.")
    val newProjectName = do readLine()
    handler.switchProject(newProjectName)
  }
  else {
    println("Unknown command - try again.")
  }
}

effect lookupProject(name: String): Project

record TimeEntry(startTime: String, endTime: String)
record Project(name: String, times: List[TimeEntry])

def println(p: Project) = println("Project(" ++ p.name ++ ")")


effect breakWith[T](value: T): Unit

def boundaryDefault[T] { body: => Unit / breakWith[T] } { default: => T } : T =
  try { body(); default() } with breakWith[T] { value => value }

def iterateProjectList(name: String, projects: List[Project]): Unit / breakWith[Project] = {
  projects.foreach {
    case project and project.name == name =>
      do breakWith(project)
    case _ => ()
  }
}

def updateProjectList(projects: List[Project], projectToUpdate: Project): List[Project] = 
{
var updateProjectList: List[Project] = []
  projects.foreach { project =>
    if (project.name == projectToUpdate.name)
      updateProjectList = updateProjectList.append([projectToUpdate])
    else
      updateProjectList = updateProjectList.append([project])
  }
  updateProjectList
}

def sumTimeEntries(times: List[TimeEntry]): Int = {
  times match {
    case Nil() => 0
    case Cons(a, rest) => {
      val timeDiff = calcTimeDiffInSecs(a.startTime, a.endTime)
      val tailSum = sumTimeEntries(rest)
      tailSum + timeDiff
    }
  }
}