module src/lib
import io/console

def helloWorld(): String = "Hello, world!"

extern def calcTimeDiffInSecs(startIsoString: String, endIsoString: String): Int =
  jsNode "Math.floor((new Date(${endIsoString}) - new Date(${startIsoString}))/1000)"

extern def getCurrentTime(): String =
  jsNode "new Date().toISOString();"

extern def convertSecsToHMS(secs: Int): String =
  jsNode "new Date(${secs} * 1000).toISOString().substr(11, 8)"




type TimerState {
  Stopped()
  Running()
}

effect startTimer(): Unit
effect stopTimer(): Unit
effect quitMainLoop(): Unit
effect switchProject(projectName: String): Unit

def handleInput(state: TimerState): Unit / { startTimer, stopTimer, quitMainLoop, switchProject } = {
  with console;
  val input = do readLine()

  if (input == "s") {
    do startTimer()
  }
  else if (input == "p") {
    do stopTimer()
  }
  else if (input == "q") {
    do quitMainLoop()
  }
  else if (input == "n") {
    println("Enter project name")
    val newProjectName = do readLine()
    do switchProject(newProjectName)
  }
  else {
    println("Unknown command")
  }
}

effect lookupProject(name: String): Project

record TimeEntry(startTime: String, endTime: String)
record Project(name: String, times: List[TimeEntry])

def println(p: Project) = println("Project(" ++ p.name ++ ")")


effect breakWith[T](value: T): Unit

def boundaryDefault[T] { body: => Unit / breakWith[T] } { default: => T } : T =
  try { body(); default() } with breakWith[T] { value => value }

def iterateProjectList(name: String, projects: List[Project]): Unit / breakWith[Project] = {
  projects.foreach {
    case project and project.name == name =>
      do breakWith(project)
    case _ => ()
  }
}

def updateProjectList(projects: List[Project], projectToUpdate: Project): List[Project] = 
{
var updateProjectList: List[Project] = []
  projects.foreach { project =>
    if (project.name == projectToUpdate.name)
      updateProjectList = updateProjectList.append([projectToUpdate])
    else
      updateProjectList = updateProjectList.append([project])
  }
  updateProjectList
}

def sumTimeEntries(times: List[TimeEntry]): Int = {
  times match {
    case Nil() => 0
    case Cons(a, rest) => {
      val timeDiff = calcTimeDiffInSecs(a.startTime, a.endTime)
      val tailSum = sumTimeEntries(rest)
      tailSum + timeDiff
    }
  }
}