import src/lib

effect lookupProject(name: String): Project

record TimeEntry(startTime: String, endTime: String)
record Project(name: String, times: List[TimeEntry])

def println(p: Project) = println("Project(" ++ p.name ++ ")")


effect breakWith[T](value: T): Unit

def boundaryDefault[T] { body: => Unit / breakWith[T] } { default: => T } : T =
  try { body(); default() } with breakWith[T] { value => value }

def iterateProjectList(name: String, projects: List[Project]): Unit / breakWith[Project] = {
  projects.foreach {
    case project and project.name == name =>
      do breakWith(project)
    case _ => ()
  }
}

def updateProjectList(projects: List[Project], projectToUpdate: Project): List[Project] = 
{
var updateProjectList: List[Project] = []
  projects.foreach { project =>
    if (project.name == projectToUpdate.name)
      updateProjectList = updateProjectList.append([projectToUpdate])
    else
      updateProjectList = updateProjectList.append([project])
  }
  updateProjectList
}

def sumTimeEntries(times: List[TimeEntry]): Int = {
  times match {
    case Nil() => 0
    case Cons(a, rest) => {
      val timeDiff = calcTimeDiffInSecs(a.startTime, a.endTime)
      val tailSum = sumTimeEntries(rest)
      tailSum + timeDiff
    }
  }
}



def mainLoop(): Unit = {
  var active: Bool = true
  var state: TimerState = Stopped()
  
  var projectList: List[Project] = []

  var currentProject: Project = Project("none", [])
  var startTime: String = ""
  var endTime: String = ""
  
  while (active) {
    try{
      println("currently on project " ++ currentProject.name)
      handleInput(state)
    } with startTimer {
      println("Timer started")
      state = Running()
      startTime = getCurrentTime()
      resume(())
    } with stopTimer {
      println("Timer stopped")
      state = Stopped()
      endTime = getCurrentTime()
      val timeEntry = TimeEntry(startTime, endTime)
      currentProject = Project(currentProject.name, currentProject.times.append([timeEntry]))
      resume(())
    } with switchProject {  projectName =>
      println("Switching project to " ++ projectName)
      projectList = updateProjectList(projectList, currentProject)
      try {
        currentProject = do lookupProject(projectName)
      } with lookupProject { name =>
        val project = boundaryDefault[Project] { iterateProjectList(name, projectList) } {
          println("Project not found, creating new project.")
          projectList = projectList.append([Project(name, [])])
          Project(name,[])
        }
        resume(project)
      }
  
    } with quitMainLoop {
      active = false
    }
  }

  projectList.foreach {
    case project =>
      println(project.name ++ ": ")
      println(sumTimeEntries(project.times))
  }

}

def main(): Unit = {
  mainLoop()
}